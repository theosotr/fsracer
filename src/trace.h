#ifndef TRACE_H
#define TRACE_H


#include <iostream>
#include <vector>

#include "operation.h"


using namespace std;
using namespace operation;


namespace interpreter {

class Interpreter;

}

namespace trace {


/** A generic class that represents a node of of the AST of traces. */
class TraceNode {
  public:
    virtual ~TraceNode() {  };
    virtual string ToString();
    virtual void Accept(interpreter::Interpreter *interpreter);
};


/** A class that represents a trace expression. */ 
class Expr {
  public:
    virtual ~Expr() {  };
    virtual void Accept(interpreter::Interpreter *interpreter);
    virtual string ToString();
};


/** An class that represents an event. */
class Event {
  public:
    enum EventType {
      S,
      M,
      W
    };

    Event(enum EventType event_type_, unsigned int event_value_):
      event_type(event_type_),
      event_value(event_value_) {  }

    Event() {  }

    void SetEventValue(unsigned int event_value_) {
      event_value = event_value_;
    }

    void SetEventType(enum EventType event_type_) {
      event_type = event_type_;
    }

    enum EventType GetEventType() {
      return event_type;
    }

    unsigned int GetEventValue() {
      return event_value;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    enum EventType event_type;
    unsigned int event_value;

};


class SyncOp : public Expr {
  public:
    SyncOp(Operation *operation_):
      operation(operation_) {  }
    SyncOp() {  }
    ~SyncOp() {
      delete operation;
    }

    Operation *GetOperation() {
      return operation;
    }

    void Accept(interpreter::Interpreter *interpreter);
    virtual string ToString();

  protected:
    Operation *operation;
};


class AsyncOp : public SyncOp {
  public:
    AsyncOp(Operation *operation_, unsigned int event_id_):
      SyncOp(operation_),
      event_id(event_id_) {  }
    ~AsyncOp() {  }

    Operation *GetOperation() {
      return operation;
    }

    void Accept(interpreter::Interpreter *interpreter);
    string ToString();

  private:
    unsigned int event_id;
};


/** This class represents the "newEvent" construct. */
class NewEventExpr : public Expr {
  public:
    NewEventExpr(unsigned int event_id_, Event event_):
      event_id(event_id_),
      event(event_) {  }

    ~NewEventExpr() {  }

    unsigned int GetEventId() {
      return event_id;
    }

    Event &GetEvent() {
      return event;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    unsigned int event_id;
    Event event;
};


/** This class represents the "link" construct. */
class LinkExpr : public Expr {
  public:
    LinkExpr(unsigned int source_ev_, unsigned int target_ev_):
      source_ev(source_ev_),
      target_ev(target_ev_) {  }

    unsigned int GetSourceEvent() {
      return source_ev;
    }

    unsigned int GetTargetEvent() {
      return target_ev;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    unsigned int source_ev;
    unsigned int target_ev;
};


/** This class represents an execution block. */
class Block : public TraceNode {
  public:
    Block(unsigned int block_id_):
      block_id(block_id_) {  }

    ~Block() {
      ClearExprs();
    }

    vector<Expr*> GetExprs() {
      return exprs;
    }

    void AddExpr(Expr *expr) {
      exprs.push_back(expr);
    }

    unsigned int GetBlockId() {
      return block_id;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    vector<Expr*> exprs;
    unsigned int block_id;

    void ClearExprs();
};


/**
 * This class represents the whole trace generated by
 * the execution of a program.
 */
class Trace : public TraceNode {
  public:
    ~Trace() {
      ClearBlocks();
    }

    vector<Block*> GetBlocks() {
      return blocks;
    };

    void AddBlock(Block *block) {
      blocks.push_back(block);
    };

    size_t GetThreadId() {
      return thread_id;
    }
    
    void SetThreadId(size_t thread_id_) {
      thread_id = thread_id_;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    vector<Block*> blocks;

    void ClearBlocks();

    size_t thread_id;
};


}

#endif
