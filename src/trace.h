#ifndef TRACE_H
#define TRACE_H


#include <iostream>
#include <vector>

#include "operation.h"


using namespace std;
using namespace operation;


namespace interpreter {

class Interpreter;

}

namespace trace {


/** A generic class that represents a node of of the AST of traces. */
class TraceNode {
  public:
    virtual ~TraceNode() {  };
    virtual string ToString();
    virtual void Accept(interpreter::Interpreter *interpreter);
};


/** A class that represents a trace expression. */ 
class Expr {
  public:
    virtual ~Expr() {  };
    virtual void Accept(interpreter::Interpreter *interpreter);
    virtual string ToString();
};


/** An class that represents an event. */
class Event {
  public:
    enum EventType {
      S,
      M,
      W
    };

    Event(enum EventType event_type_, size_t event_value_):
      event_type(event_type_),
      event_value(event_value_) {  }

    Event() {  }

    void SetEventValue(size_t event_value_) {
      event_value = event_value_;
    }

    void SetEventType(enum EventType event_type_) {
      event_type = event_type_;
    }

    enum EventType GetEventType() {
      return event_type;
    }

    size_t GetEventValue() {
      return event_value;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    enum EventType event_type;
    size_t event_value;

};


class SubmitOp : public Expr {
  public:
    enum Type {
      ASYNC,
      SYNC
    };

    SubmitOp(size_t id_, string name_, enum Type type_):
      id(id_),
      name(name_),
      type(type_) {  }
    ~SubmitOp() {  }

    void Accept(interpreter::Interpreter *interpreter);
    string ToString();

  private:
    size_t id;
    string name;
    enum Type type;
};


class ExecOp : public TraceNode {
  public:
    ExecOp(size_t id_):
      id(id_) {  }
    ~ExecOp() {
      ClearOperations();
    }

    void AddOperation(Operation *operation) {
      operations.push_back(operation);
    }

    vector<Operation *> GetOperations() {
      return operations;
    }

    void Accept(interpreter::Interpreter *interpreter);
    string ToString();

  private:
    size_t id;
    vector<Operation *> operations;

    void ClearOperations();
};

/** This class represents the "newEvent" construct. */
class NewEventExpr : public Expr {
  public:
    NewEventExpr(size_t event_id_, Event event_):
      event_id(event_id_),
      event(event_) {  }

    ~NewEventExpr() {  }

    size_t GetEventId() {
      return event_id;
    }

    Event &GetEvent() {
      return event;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    size_t event_id;
    Event event;
};


/** This class represents the "link" construct. */
class LinkExpr : public Expr {
  public:
    LinkExpr(size_t source_ev_, size_t target_ev_):
      source_ev(source_ev_),
      target_ev(target_ev_) {  }

    size_t GetSourceEvent() {
      return source_ev;
    }

    size_t GetTargetEvent() {
      return target_ev;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    size_t source_ev;
    size_t target_ev;
};


/** This class represents an execution block. */
class Block : public TraceNode {
  public:
    Block(size_t block_id_):
      block_id(block_id_) {  }

    ~Block() {
      ClearExprs();
    }

    vector<Expr*> GetExprs() {
      return exprs;
    }

    void AddExpr(Expr *expr) {
      exprs.push_back(expr);
    }

    size_t GetBlockId() {
      return block_id;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    vector<Expr*> exprs;
    size_t block_id;

    void ClearExprs();
};


/**
 * This class represents the whole trace generated by
 * the execution of a program.
 */
class Trace : public TraceNode {
  public:
    ~Trace() {
      ClearBlocks();
    }

    vector<Block*> GetBlocks() {
      return blocks;
    };

    vector<ExecOp*> GetExecOps() {
      return exec_ops;
    }

    void AddBlock(Block *block) {
      blocks.push_back(block);
    };

    void AddExecOp(ExecOp *exec_op) {
      exec_ops.push_back(exec_op);
    }

    size_t GetThreadId() {
      return thread_id;
    }
    
    void SetThreadId(size_t thread_id_) {
      thread_id = thread_id_;
    }

    void Accept(interpreter::Interpreter *interpreter);

    string ToString();

  private:
    vector<Block*> blocks;
    vector<ExecOp*> exec_ops;
    size_t thread_id;

    void ClearBlocks();
    void ClearExecOps();
};


}

#endif
